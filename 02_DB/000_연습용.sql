SELECT EMP_ID , EMP_NAME , SALARY , HIRE_DATE FROM EMPLOYEE;

-- 300만 이상
SELECT EMP_ID , EMP_NAME , JOB_CODE , HIRE_DATE 
FROM EMPLOYEE
WHERE SALARY >= 3000000
ORDER BY SALARY DESC;

/* 부서명을 입력 받아 해당 부서에 존재하는 사원의 
 * 사번, 이름, 급여, 부서명을 사번 오름차순으로 조회 */
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_TITLE 
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE DEPT_TITLE ='총무부'
ORDER BY EMP_ID;

-- SQL을 바꾸는 방법
SELECT * FROM (
   SELECT EMP_ID, EMP_NAME, SALARY, NVL(DEPT_TITLE, 'null') DEPT_TITLE
   FROM EMPLOYEE 
   LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
   ORDER BY EMP_ID )
WHERE DEPT_TITLE = 'null';

SELECT NVL(DEPT_TITLE,'부서없음') , JOB_NAME, EMP_NAME , EMAIL
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE =  DEPT_ID)
JOIN JOB USING (JOB_CODE);

SELECT EMP_ID, EMP_NAME, NVL(DEPT_TITLE,'없음') DEPT_TITLE, JOB_NAME, NVL(PHONE,'없음') PHONE
FROM EMPLOYEE
NATURAL JOIN JOB
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE EMP_ID = 200
;

SELECT EMP_ID, EMP_NAME, NVL(DEPT_TITLE,'없음') DEPT_TITLE, JOB_NAME, NVL(PHONE,'없음') PHONE
FROM EMPLOYEE
NATURAL JOIN JOB
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE EMP_NAME LIKE '%동%'
;

SELECT EMP_ID, EMP_NAME, NVL(DEPT_TITLE,'없음') DEPT_TITLE, JOB_NAME, NVL(PHONE,'없음') PHONE
FROM EMPLOYEE
NATURAL JOIN JOB
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE SALARY BETWEEN 3000000 AND 4000000
;

SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE
NATURAL JOIN JOB
WHERE SALARY BETWEEN 2000000 AND 3000000
ORDER BY SALARY DESC
;

-- 사번 생성 시퀀스(223번 시작)
CREATE SEQUENCE SEQ_EMP_ID
START WITH 223 -- 223번 시작
INCREMENT BY 1 -- 1씩 증가
NOCYCLE -- 반복 없음
NOCACHE; -- 미리 만들어 두는 번호 없음

-- SEQ_EMP_ID.NEXTVAL : 다음 번호 생성
-- SEQ_EMP_ID.CURRVAL : 현재 번호 조회

UPDATE 테이블명
SET 컬럼명 = 수정할 값,
	컬럼명 = 수정할 값,
	컬럼명 = 수정할 값
WHERE 조건;

UPDATE EMPLOYEE
SET EMAIL = ?,
	PHONE = ?,
	SALARY = ?
WHERE EMP_ID = ?
;

SELECT EMP_ID , EMP_NAME , PHONE , EMAIL , SALARY FROM EMPLOYEE
WHERE EMP_ID = 223; 

SELECT EMP_ID, EMP_NAME, ENT_YN, ENT_DATE 
FROM EMPLOYEE 
WHERE EMP_ID = ?;

UPDATE EMPLOYEE
SET ENT_YN = 'N',
	ENT_DATE = SYSDATE 
WHERE EMP_ID = 223
;

SELECT ENT_YN,ENT_DATE 
FROM EMPLOYEE
WHERE EMP_ID = 223;

ROLLBACK;

/* 현재 재직중인 사원의
   사번, 이름, 부서명, 직급명, 급여, 전화번호, 이메일
   직급코드 오름차순으로 조회 */

SELECT EMP_ID , EMP_NAME , NVL(DEPT_TITLE,'없음') DEPT_TITLE, JOB_NAME, SALARY , 
NVL(PHONE,'없음') PHONE , EMAIL
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
LEFT JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID)
WHERE ENT_YN = 'N'
ORDER BY JOB_CODE; 

/* 사번으로 사원 정보 수정*/
UPDATE EMPLOYEE 
SET EMAIL = ?,
	PHONE = ?,
	SALARY = ?,
	BONUS = ?
WHERE EMP_ID = ?
;

SELECT EMAIL,PHONE,SALARY,BONUS
FROM EMPLOYEE
WHERE EMP_ID = '223';

INSERT INTO EMPLOYEE

VALUES ();

-- 입력 받은 사번의 사원이 존재하지 않으면 0
-- 사원은 있는데 퇴직 처리된 사원이면 1
-- 사원도 있고, 재직중인 사원이면 2 조회


SELECT 
	CASE
		-- 존재하지는 않는 사원?
		WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 222) = 0 
		THEN 0
		
		-- 존재하지만 퇴직한 사원?
		WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 222 AND ENT_YN ='Y') = 1  
		
		THEN 1
		
		--- 존재하지만 퇴직하지 않은 사원!
		ELSE 2
	END	"CHECK"
FROM DUAL;

SELECT 
	CASE
		WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 222) = 0 
		THEN 0
		WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 222 AND ENT_YN ='Y') = 1  
		THEN 1
		ELSE 2
	END	"CHECK"
FROM DUAL;

ROLLBACK;

UPDATE EMPLOYEE 
SET ENT_YN = 'Y',
    ENT_DATE = SYSDATE 
WHERE EMP_ID = 223
;

SELECT ENT_YN 
FROM EMPLOYEE
WHERE EMP_ID = '200';

UPDATE EMPLOYEE 
SET ENT_YN = 'N'
WHERE EMP_ID = '200'
;

COMMIT;

/*// 가장 최근(입사일이 늦은) 사원 5명의
				// 사번, 이름, 부서명, 입사일을
				// 입사일 내림차순으로 조회*/

SELECT * FROM 
	  (SELECT EMP_ID , EMP_NAME , NVL(DEPT_TITLE,'부서없음') , HIRE_DATE 
	  FROM EMPLOYEE 
	  LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
	  ORDER BY HIRE_DATE  DESC)
WHERE ROWNUM <=5;


SELECT EMP_ID , EMP_NAME , NVL(DEPT_TITLE,'부서없음') , HIRE_DATE 
FROM EMPLOYEE 
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
ORDER BY HIRE_DATE  DESC;

/*// 각 부서별
				// 부서명, 인원 수, 급여 평균
				// 부서코드 오름차순 조회*/

SELECT DEPT_CODE , NVL(DEPT_TITLE,'부서없음') , COUNT(*) 인원, FLOOR(AVG(SALARY)) 평균  
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE= DEPT_ID)
GROUP BY DEPT_CODE, DEPT_TITLE
ORDER BY DEPT_CODE
;
